## 并发测试对比结果

### 测试环境
- 测试所用的机器配置：11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz，8核16线程，内存32G，显卡英伟达RTX 3060 <br>
- JMeter Version：5.4.1

### 测试配置
JMeter线程组：100用户，循环50次


### 测试结果
#### JVM本地锁并发量（利用MP进行查询修改库存）

|        类型         | synchronized 并发量 |  ReentrantLock 并发量  |
|:-----------------:|:----------------:|:-------------------:|
|     Singleton     |   495.148/sec    |     495.344/sec     |
|     Prototype     |       并发失效       |        并发失效         |
| Transactional（单例） |       并发失效       | 824.131/sec(转成读未提交) |
|   2台Nginx集群（单例）   |       并发失效       |        并发失效         |

#### SQL 原子性并发量（使用原生 SQL 进行查询修改库存）

|        类型         |  无JVM锁并发量   | 
|:-----------------:|:-----------:|
|     Singleton     | 915.919/sec | 
|     Prototype     | 943.752/sec | 
| Transactional（单例） | 813.14/sec  | 
|   2台Nginx集群（单例）   | 924.898/sec | 

#### 悲观锁（SELECT ... FOR UPDATE）

|            类型            |  无JVM锁并发量   | 
|:------------------------:|:-----------:|
|    Transactional（单例）     | 601.757/sec |
| 2台Nginx集群（Transactional） | 544.247/sec |

### 结论
1. JVM 本地锁仅为**单例**的情况下有效，其他情况（比如：多例、事务、以及集群）会失效，关于事务转成读未提交，实际中不考虑，按失效来处理；
2. SQL 原子性并发下，并发量性能为：多例（集群） > 单例 > 事务；
3. 悲观锁下，并发量性能为：单例事务 > 集群事务；
4. 整体性能对比，SQL 原子性并发量 > 悲观锁 > JVM锁。

**备注**：测试结果非精确性，多次测试结果会有所差异，以及测试的标准不统一，同时各个设备测试性能有所差异，数据仅作参考。<br>
